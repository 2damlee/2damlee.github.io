---
title: "Recursion-2"
categories:
  - Algorithm
layout: archive
sidebar_main: true
author_profile: true
---

<br><br>

### Recursionì˜ ì‘ìš©

<br>



ì˜ˆì œ1) **ë¯¸ë¡œ ì°¾ê¸°**

dicision Problem: yes or no - ì¶œêµ¬ê°€ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ í™•ì¸

í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì¶œêµ¬ê¹Œì§€ ê°€ëŠ” ê²½ë¡œê°€ ìˆìœ¼ë ¤ë©´ 1) í˜„ì¬ ìœ„ì¹˜ê°€ ì¶œêµ¬ì´ê±°ë‚˜ 2) ì´ì›ƒí•œ ì…€ë“¤ ì¤‘ í•˜ë‚˜ì—ì„œ <u>í˜„ì¬ ìœ„ì¹˜ë¥¼ ì§€ë‚˜ì§€ ì•Šê³ </u> ì¶œêµ¬ê¹Œì§€ ê°€ëŠ” ê²½ë¡œê°€ ìˆì–´ì•¼ í•œë‹¤.

<br>

sudo code

```
boolean findpath(x, y)
  if (x, y) is the exit
  	return true;
  else
  	mark (x, y) as a visited cell;
  	for each neighbouring cell (x', y') of (x, y) do
  		if (x', y') is on the pathway and not visited
  			if findPath(x', y')
  				return true;
  	return false;
```

x, yê°€ ì¶œêµ¬ë¼ë©´ true, ì•„ë‹ˆë¼ë©´ ë°©ë¬¸í•œ ì¢Œí‘œë¥¼ í‘œì‹œ í›„ ê¸¸ì´ ìˆê±°ë‚˜ ë°©ë¬¸í•œ ì¢Œí‘œê°€ ì•„ë‹ˆë¼ë©´ findPath()í•¨ìˆ˜ë¥¼ ë°˜ë³µ. 

í˜¹ì€, ğŸ‘‡

````
boolean findPath(x, y)
	if (x, y) is either on the wall or a visited cell
		return false;
	else if (x, y) is the exit
		return true;
	else
		mark (x, y) as a visited cell;
		for each neighbouring cell (x', y') of (x, y) do
			if findPath(x', y')
				return true;
			return false;
````

<br>

ğŸ‘‡ ìë°” ì½”ë“œë¡œ êµ¬í˜„

```java
public class Maze {

  private static int N=8;
  private static int [][] maze = {
    {0, 0, 0, 0, 0, 0, 0, 1}, 
    {0, 1, 1, 0, 1, 1, 0, 1},
    {0, 0, 0, 1, 0, 0, 0, 1}, 
    {0, 1, 0, 0, 1, 1, 0, 0}, 
    {0, 1, 1, 1, 0, 0, 1, 1}, 
    {0, 1, 0, 0, 0, 1, 0, 1}, 
    {0, 0, 0, 1, 0, 0, 0, 1}, 
    {0, 1, 1, 1, 0, 1, 0, 0}
  };
  private static final int pathway = 0;
  private static final int wall = 1;
  private static final int blocked = 2;
  private static final int path = 3; // ë§ëŠ” ê¸¸ì¸ì§€ í‹€ë¦° ê¸¸ì¸ì§€ ì²´í¬í•˜ëŠ” ë³€ìˆ˜
	
  
  public static boolean findMazePath(int x, int y) {
  	if (x<0 || y<0 || x>=N || y>=N) // ë¯¸ë¡œ ì˜ì—­ì„ ë²—ì–´ë‚˜ëŠ” ê²½ìš°
    	return false;
  	else if (maze[x][y] != pathway)
    	return false;
  	else if (x==N-1 && y==N-1) { // ì¶œêµ¬ 
      maze[x][y] = path;
      return true;
    }
    else {
      maze[x][y] = path; // ì§€ë‚˜ê°„ ê¸¸ ì²´í¬ 
      if (findMazePath(x-1, y) || findMazePath(x, y+1)
         || findMazePath(x+1, y) || findMazePaht(x, y-1)) { // ë™ì„œë‚¨ë¶ ë°©í–¥ ëª¨ë‘ ì²´í¬ 
        return true;
      }
      maze[x][y] = blocked;
      return false;
    }
	}
  
  public static void main(String[] args) {
    printMaze();
    findMazePath(0, 0);
    printMaze();
  }
}

```



<br><br>

ì˜ˆì œ2) **Counting Cells in a Blob**

<br>

<img src="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-06-30%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.03.40.png" alt="á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2021-06-30 á„‹á…©á„’á…® 4.03.40" style="zoom:50%;" />

Binary ì´ë¯¸ì§€, ê° í”½ì…€ì€ background pixel ì´ê±°ë‚˜ image pixelì´ë‹¤. ì„œë¡œ ì—°ê²°ëœ image pixelë“¤ì˜ ì§‘í•©ì„ blobì´ë¼ê³  ë¶€ë¥¸ë‹¤. ìƒí™”ì¢Œìš° ë° ëŒ€ê°ì„  ë°©í–¥ìœ¼ë¡œë„ ì—°ê²°ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼ëœë‹¤. 

<br>

ì…ë ¥: n*n í¬ê¸°ì˜ 2ì°¨ì› ê·¸ë¦¬ë“œ, í•˜ë‚˜ì˜ ì¢Œí‘œëŠ” (x, y)

ì¶œë ¥: í”½ì…€ (x, y)ê°€ í¬í•¨ëœ blobì˜ í¬ê¸°

<br>

sudo code

```
Algorithm for countCells(x, y)
if the pixel (x, y) is outside the grid
	the result is 0;
else if pixel (x, y) is not an image pixel or already counted
	the result is 0;
else
	set the colour of the pixel (x, y) to a red colour;
	the result is 1 plus the number of cells in each piece of the blob 
	that includes a neares neighbour;
```

<br>



ğŸ‘‡ìë°” ì½”ë“œë¡œ êµ¬í˜„

```java
private static int bacground = 0;
private static int image = 0;
private static counted = 2;

public int countCells(int x, int y) {
  if (x<0 || x>=N || y<0 || y>=N) 
    return 0;
  else if (grid[x][y] != image)
    return 0;
  else {
    grid[x][y] = counted;
    return 1 + countCells(x-1, y+1) + countCells(x-1, y+1) 
      + countCells(x+1, y+1) + countCells(x-1, y) 
      + countCells(x+1, y) + countCells(x-1, y-1) 
      + countCells(x, y-1) + countCells(x+1, y-1);
  }
}
```

